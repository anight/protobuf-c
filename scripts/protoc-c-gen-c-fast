#!/usr/bin/env python
"""
Copyright (C) 2014 Andrei Nigmatulin
Copyright (C) 2012 Roman Lomonosov

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
 
THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
"""

VERSION = "1.4"


MESSAGE_GENERATED_METHODS = """
void ${message_type}__init
                     (${MessageType} *message)
{
	static ${MessageType} init_value = ${MESSAGE_TYPE}__INIT;
	*message = init_value;
}

size_t ${message_type}__get_packed_size
                     (const ${MessageType} *message)
{
	assert(message->base.descriptor == &${message_type}__descriptor);
	${get_packed_size__additional_variables}
	size_t sz = 0;
	${get_packed_size_fields}
	return sz;
}

size_t ${message_type}__pack
                     (const ${MessageType} *message,
                      uint8_t *out)
{
	assert(message->base.descriptor == &${message_type}__descriptor);
	uint8_t *p = out;
	${pack__additional_variables}
	${pack_fields}
	return p - out;
}

size_t ${message_type}__pack_to_buffer
                     (const ${MessageType} *message,
                      ProtobufCBuffer *buffer)
{
	assert(message->base.descriptor == &${message_type}__descriptor);
	return protobuf_c_message_pack_to_buffer_slow(&message->base, buffer);
}

int ${message_type}__unpack_merge
                     (${MessageType} *message,
                      const uint8_t *buffer, size_t buffer_size,
                      ProtobufCAllocator *allocator)
{
	assert(message->base.descriptor == &${message_type}__descriptor);
	const uint8_t *buffer_end = buffer+buffer_size;
	${merge_unpack__additional_variables}
	${required_fields_init}

	while (buffer < buffer_end) {
		${switch_tree}
	}

	${required_fields_check}
	return 0;
}

${MessageType} *${message_type}__unpack
                     (ProtobufCAllocator *allocator,
                      size_t len, const uint8_t *data)
{
	if (allocator == NULL)
		allocator = &protobuf_c_default_allocator;
	${MessageType} *m = memory_allocate(sizeof(*m), allocator);
	if (m == NULL) return NULL;
	${message_type}__init(m);
	if (0 > ${message_type}__unpack_merge(m, data, len, allocator)) {
		${message_type}__free_unpacked(m, allocator);
		return NULL;
	}
	return m;
}

void ${message_type}__free_unpacked
                     (${MessageType} *message,
                      ProtobufCAllocator *allocator)
{
	if (allocator == NULL)
		allocator = &protobuf_c_default_allocator;
	${free_unpacked__additional_variables}
	${free_fields}
	memory_free(message, allocator);
}

protobuf_c_boolean ${message_type}__check
                     (const ${MessageType} *message)
{
	${check__additional_variables}
	if (message == NULL || message->base.descriptor != &${message_type}__descriptor)
		return 0;
	${check_fields}
	return 1;
}

"""

OPTIONAL = 1
REQUIRED = 2
REPEATED = 3

TYPE_ID_TO_NAME_MAP = { # type attribute (from google's _pb2.py file) to type name map
	1: 'double',
	2: 'float',
	3: 'int64',
	4: 'uint64',
	5: 'int32',
	6: 'fixed64',
	7: 'fixed32',
	8: 'bool',
	9: 'string',
	11: 'submessage',
	12: 'bytes',
	13: 'uint32',
	14: 'enum',
	15: 'sfixed32',
	16: 'sfixed64',
	17: 'sint32',
	18: 'sint64',
}

FIELD_TYPE_MAP = {} # maps field type name to wrapper class. filled by "field_type" decorator

#####################
# tempalates and helpers
#####################

def render_value(key, *data_array):

	found = False
	value = None

	for data in data_array:

		try:
			value = data[key]
			found = True
			break
		except (KeyError,TypeError):
			pass

		try:
			value = data[int(key)]
			found = True
			break
		except (KeyError,ValueError,IndexError):
			pass

		value = getattr(data, key, None)
		if not value is None:
			found = True
			break

	if not found:
		raise ValueError("key %s not found in %s" % (str(key), str(data_array)))

	if found:
		if callable(value):
			value = value()

	return str(value)

def render(template, *data):
	out = []
	for line in template.split("\n"):
		p1 = line.find("${")
		has_var = False
		while p1 >= 0:
			has_var = True
			p2 = line.find("}",p1)
			if p2 < 0: raise ValueError("Variable not closed: %s" % str([line,]))
			key = line[p1+2:p2]
			if line.strip() == ("${%s}" % key):
				t = []
				for l in render_value(key, *data).split("\n"):
					t.append(line[:p1]+l)
				line = "\n".join(t)
			else:
				line = line[:p1]+render_value(key, *data)+line[p2+1:]
			p1 = line.find("${")
		if has_var and not line.strip():
			continue
		out.append(line)
	out = "\n".join(out).split("\n")
	# fix intendation
	min_intendation = None
	for l in out:
		if not l.strip(): continue
		p = l.find(l.strip())
		if min_intendation is None or p < min_intendation:
			min_intendation = p
	if not min_intendation:
		return "\n".join(out)
	res = []
	for l in out:
		if not l.strip():
			res.append("")
			continue
		res.append(l[min_intendation:])

	# skip empty lines on start
	while res and not res[0].split():
		res = res[1:]
	# and at finish
	while res and not res[-1].split():
		res = res[:-1]
	return "\n".join(res)

def to_underlines(TypeName):
	""" TypeName -> type_name """
	type_name = ""
	for i,c in enumerate(TypeName):
		if c.lower() != c and c.upper() == c and i != 0 and TypeName[i-1].upper() != TypeName[i-1]:
			type_name += "_"
		type_name += c.lower()
	return type_name.replace(".","__")

def to_TypeName(s):
	r = ''
	prev_not_letter = True
	for c in s:
		if (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z'):
			if prev_not_letter:
				r += c.upper()
			else:
				r += c
			prev_not_letter = False
		elif c == '.':
			r += '__'
			prev_not_letter = True
		elif c == '_':
			prev_not_letter = True
		else:
			r += c
	return r

#####################
# <fields>
#####################

def field(C):
	type_name = C.__name__[1:]
	if not type_name in TYPE_ID_TO_NAME_MAP.values():
		raise ValueError("unknown type %s" % type_name)
	if type_name in FIELD_TYPE_MAP:
		raise ValueError("field %s already implemented" % type_name)
	FIELD_TYPE_MAP[type_name] = C
	C.type_name = type_name
	return C

def get_field(protobuf_field):
	C = FIELD_TYPE_MAP[TYPE_ID_TO_NAME_MAP[protobuf_field.type]]
	return C(protobuf_field)

class _base(object):
	"""
	@todo: Only repeated fields of primitive numeric types
	(types which use the varint, 32-bit, or 64-bit wire types) can be declared "packed".
	"""
	repeated_init_size = 8
	read_convert_type = ""

	def __init__(self, protobuf_field):
		self._field = protobuf_field

	def render(self, template, *data):
		if type(template) is list:
			return render("\n".join([s for s in template if s]),self)
		return render(template, self, *data)

	def field_full_name(self):
		return to_underlines(self._message.full_name + '.' + self._field.name).lower()

	def is_optional(self):
		return self._field.label == OPTIONAL

	def is_repeated(self):
		return self._field.label == REPEATED

	def is_required(self):
		return self._field.label == REQUIRED

	def is_complex(self):
		return self.type_name in ('string', 'bytes', 'submessage')

	def has_default_value(self):
		return self._field.HasField('default_value')

	def is_packed(self):
		return self._field.HasField('options') and self._field.options.HasField('packed') and self._field.options.packed

	def _tag(self, wire_type):
		b = []
		v = (self._field.number << 3) + wire_type
		while True:
			t = v & 0x7f
			v = v>>7
			if v > 0:
				b.append(t|0x80)
			else:
				b.append(t)
				break
		return b

	def tag(self):
		return self._tag(self.wire_type)

	def tag_packed(self):
		return self._tag(2)

	def tag_size(self):
		return len(self.tag())

	def can_be_packed(self):
		return self.is_repeated() and self.wire_type in (0,1,5)

	def cases(self):
		if self.can_be_packed():
			return [
				(self.tag(), self.read()),
				(self.tag_packed(), self.read_packed()),
			]
		return [
				(self.tag(), self.read()),
		]

	def name(self):
		return self._field.name.lower()

	def scalar(self):
		if self.is_repeated():
			return self.render("message->${name}[i]")
		return self.render("message->${name}")

	def number(self):
		if not self.is_repeated():
			raise Exception("method number called for non-repeated field")
		return self.render("message->n_${name}")

	def vector(self):
		if not self.is_repeated():
			raise Exception("method number called for non-repeated field")
		return self.render("message->${name}")

	def has(self):
		if not self.is_optional() or self.type_name in ('string', 'submessage'):
			raise Exception("method 'has' called for non-optional field or type is string or submessage")
		return self.render("message->has_${name}")

	def next_scalar(self):
		if self.is_repeated():
			return self.render("${vector}[${number}]")
		return self.render("${scalar}")

	def default_value(self):
		if not self.has_default_value():
			raise Exception("no default value for field")
		if self.type_name == 'bytes':
			return self.render("${field_full_name}__default_value_data")
		return self.render("${field_full_name}__default_value")

	def pack_with_length_prediction(self):
		if self.is_packed() and self.wire_type == 0:
			return True
		if self.type_name == 'submessage':
			return True
		return False

	def optional_needs_packing(self):
		if not self.is_optional():
			raise Exception("method called for non-optional field")
		conditions = []
		if self.type_name in ('string', 'submessage'):
			conditions.append("${scalar} != NULL")
		else:
			conditions.append("${has}")
		if self.type_name == 'string' and self.has_default_value():
			conditions.append("${scalar} != ${default_value}")
		return self.render(" && ".join(conditions))

	def repeated_check_resize(self):
		if not self.is_repeated():
			return ""
		return self.render("""
			if ( ((${number}-1) & (${number})) == 0) {
				if (${number} == 0) {
					if ((${vector} = memory_allocate(${repeated_init_size}*sizeof(${c_type}), allocator)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
				} else if (${number} >= ${repeated_init_size}) {
					void *new_ptr = memory_allocate_copy(2*${number}*sizeof(${c_type}), allocator,
						(uint8_t*)${vector}, ${number}*sizeof(${c_type}));
					if (new_ptr == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
					${vector} = new_ptr;
				}
			}
		""")

	def repeated_increment_count(self):
		if not self.is_repeated():
			return ""
		return "${number}++;"

	def has_value_set_true(self):
		if self.is_optional():
			return "${has} = 1;"
		return ""

	def has_required_field(self):
		if hasattr(self, '_required_field_id'):
			return "required_fields[%u] |= (1UL << %u);" % (self._required_field_id / 64, self._required_field_id % 64)
		return ""

	def read_function(self):
		return "read_${type_name}"

	def read(self):
		if self.is_repeated():
			return self.render("""
				${repeated_check_resize}
				if ((buffer=${read_function}(${read_convert_type}&${next_scalar}, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
				${repeated_increment_count}
			""")
		return self.render("""
			if ((buffer=${read_function}(${read_convert_type}&${scalar}, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
			${has_value_set_true}
			${has_required_field}
		""")

	def read_packed(self):
		return self.render("""
			if ((buffer=read_int32(&t, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
			tmp_buffer_pointer = buffer+t;
			if (tmp_buffer_pointer > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
			while (buffer < tmp_buffer_pointer) {
				${read}
			}
			if (buffer > tmp_buffer_pointer) return PROTOBUF_C__WRONG_MESSAGE;
		""")

	def get_packed_size(self):
		return self.render(str(self.wire_size))

	def repeated_get_packed_size(self):
		if type(self.wire_size) is int:
			return self.render("rv = ${wire_size} * ${number};")

		return self.render("""
			rv = 0;
			for (i = 0; i < ${number}; i++) {
				rv += ${get_packed_size};
			}
		""")

	def pack_tag(self):
		return " ".join( "*p++ = '\\x%x';" % c for c in self.tag() )

	def pack_packed_tag(self):
		return " ".join( "*p++ = '\\x%x';" % c for c in self.tag_packed() )

	def pack_length_prologue(self):
		if self.pack_with_length_prediction():
			if self.type_name == 'submessage':
				return self.render("""
					varint_length_p = p;
					reserved_length = 1;
					p++;
				""")
			else:
				return self.render("""
					varint_length_p = p;
					reserved_length = uint32_size(${number} * ${wire_min_size});
					p += reserved_length;
				""")
		if self.is_packed() and type(self.wire_size) is int:
			return "p += uint32_pack(${number} * ${wire_size}, p);"
		return ""

	def pack_length_epilogue(self):
		if self.pack_with_length_prediction():
			return self.render("""
				length = p - (varint_length_p + reserved_length);
				varint_length = uint32_size(length);
				if (varint_length != reserved_length) {
					memmove(varint_length_p + varint_length, varint_length_p + reserved_length, length);
				}
				uint32_pack(length, varint_length_p);
			""")
		return ""

	def pack_scalar(self):
		return "p += ${wire_pack};"

	def pack(self):
		return self.render("""
			${pack_tag}
			${pack_length_prologue}
			${pack_scalar}
			${pack_length_epilogue}
		""")


class _varint(_base):
	wire_type = 0
	c_type = "uint64_t"
	wire_min_size = 1

@field
class _int32(_varint):
	c_type = "int32_t"
	wire_size = "int32_size(${scalar})"
	wire_pack = "int32_pack(${scalar}, p)"

@field
class _uint32(_varint):
	c_type = "uint32_t"
	wire_size = "uint32_size(${scalar})"
	wire_pack = "uint32_pack(${scalar}, p)"

@field
class _sint32(_varint):
	c_type = "int32_t"
	wire_size = "sint32_size(${scalar})"
	wire_pack = "sint32_pack(${scalar}, p)"

@field
class _int64(_varint):
	c_type = "int64_t"
	wire_size = "uint64_size(${scalar})"
	wire_pack = "uint64_pack(${scalar}, p)"

@field
class _uint64(_varint):
	c_type = "uint64_t"
	wire_size = "uint64_size(${scalar})"
	wire_pack = "uint64_pack(${scalar}, p)"

@field
class _sint64(_varint):
	c_type = "int64_t"
	wire_size = "sint64_size(${scalar})"
	wire_pack = "sint64_pack(${scalar}, p)"

@field
class _bool(_varint):
	wire_size = 1
	c_type = "protobuf_c_boolean"
	wire_pack = "boolean_pack(${scalar}, p)"

@field
class _enum(_varint):
	c_type = "int"
	read_convert_type = "(int *)"
	wire_size = "uint32_size((uint32_t)${scalar})"
	wire_pack = "uint32_pack((uint32_t)${scalar}, p)"

@field
class _fixed32(_base):
	wire_type = 5
	wire_size = 4
	c_type = "uint32_t"
	read_function = "read_fixed32"
	wire_pack = "fixed32_pack(${scalar}, p)"
	wire_min_size = 4

@field
class _sfixed32(_fixed32):
	c_type = "int32_t"
	read_convert_type = "(uint32_t *)"
	wire_pack = "fixed32_pack((uint32_t)${scalar}, p)"

@field
class _float(_fixed32):
	c_type = "float"
	read_convert_type = "(uint32_t *)"
	wire_pack = "fixed32_pack_p(&${scalar}, p)"

@field
class _fixed64(_base):
	wire_type = 1
	wire_size = 8
	c_type = "uint64_t"
	read_function = "read_fixed64"
	wire_pack = "fixed64_pack(${scalar}, p)"
	wire_min_size = 8

@field
class _sfixed64(_fixed64):
	c_type = "int64_t"
	read_convert_type = "(uint64_t *)"
	wire_pack = "fixed64_pack((uint64_t)${scalar}, p)"

@field
class _double(_fixed64):
	c_type = "double"
	read_convert_type = "(uint64_t *)"
	wire_pack = "fixed64_pack_p(&${scalar}, p)"

@field
class _string(_base):
	wire_type = 2
	c_type = "char*"
	wire_size = "string_size(${scalar})"
	wire_pack = "string_pack(${scalar}, p)"

	def read(self):
		return self.render("""
			${repeated_check_resize}
			if ((buffer=read_uint32(&length, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
			if (buffer + length > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
			if ((${next_scalar} = memory_allocate_copy(length+1,
					allocator, buffer, length)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
			${next_scalar}[length] = 0;
			buffer += length;
			${repeated_increment_count}
			${has_required_field}
		""")

	def free(self):
		if self.has_default_value(): # not repeated
			return self.render("""
				if (${scalar} != NULL && ${scalar} != ${default_value})
					memory_free(${scalar}, allocator);
				""")
		return self.render("memory_free(${scalar}, allocator);")

@field
class _submessage(_base):
	"""
	@todo:For embedded message fields, the parser merges multiple instances
	of the same field, as if with the Message::MergeFrom method -
	that is, all singular scalar fields in the latter instance replace those in the former,
	singular embedded messages are merged, and repeated fields are concatenated.
	"""
	wire_type = 2
	wire_size = "submessage_size(${submessage}__get_packed_size(${scalar}))"
	wire_pack = "${submessage}__pack(${scalar}, p)"

	def field_type_name(self):
		if self._field.type_name.startswith('.'):
			return self._field.type_name[1:]
		return self._message.full_name + '.' + self._field.type_name

	def submessage_type(self):
		return to_TypeName(self.field_type_name())

	def c_type(self):
		return "%s*" % self.submessage_type()

	def submessage(self):
		return to_underlines(self.field_type_name()).lower()

	def submessage_tmp(self):
		return self.render("""
			${submessage_type} *submessage_tmp = memory_allocate(sizeof(${submessage_type}), allocator);
			if (submessage_tmp == NULL) {
				return PROTOBUF_C__NOT_ENOUGH_MEMORY;
			}
			${submessage}__init(submessage_tmp);
		""")

	def read(self):
		ret = """
				${repeated_check_resize}
				if ((buffer=read_uint32(&length, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
				if (buffer + length > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
				buffer += length;
		"""
		if self.is_repeated():
			ret+="""
				{
					${submessage_tmp}
					t = ${submessage}__unpack_merge(submessage_tmp, buffer-length, length, allocator);
					if (t < 0) {
						${submessage}__free_unpacked(submessage_tmp, allocator);
						return t;
					}
					${next_scalar} = submessage_tmp;
				}
			"""
		else: # merge support
			ret+="""
				if (${next_scalar} == NULL) {
					${submessage_tmp}
					t = ${submessage}__unpack_merge(submessage_tmp, buffer-length, length, allocator);
					if (t < 0) {
						${submessage}__free_unpacked(submessage_tmp, allocator);
						return t;
					}
					${next_scalar} = submessage_tmp;
				} else {
					t = ${submessage}__unpack_merge(${next_scalar}, buffer-length, length, allocator);
					if (t < 0) return t;
				}
			"""

		ret+= """
				${repeated_increment_count}
				${has_required_field}
		"""

		return self.render(ret)

	def free(self):
		return self.render("if (${scalar} != NULL) ${submessage}__free_unpacked(${scalar}, allocator);")

@field
class _bytes(_base):
	wire_type = 2
	c_type = "ProtobufCBinaryData"
	wire_size = "bytes_size(${scalar})"
	wire_pack = "binary_data_pack(&${scalar}, p)"

	def read(self):
		return self.render("""
			${repeated_check_resize}
			if ((buffer=read_uint32(&length, buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;
			if (buffer + length > buffer_end) return PROTOBUF_C__WRONG_MESSAGE;
			if ((${next_scalar}.data = memory_allocate_copy(length,
					allocator, buffer, length)) == NULL) return PROTOBUF_C__NOT_ENOUGH_MEMORY;
			${next_scalar}.len = length;
			buffer += length;
			${repeated_increment_count}
			${has_value_set_true}
			${has_required_field}
		""")

	def free(self):
		if self.has_default_value():
			return self.render("""
				if (${scalar}.data != NULL && ${scalar}.data != ${default_value})
					memory_free(${scalar}.data, allocator);
				""")
		return self.render("memory_free(${scalar}.data, allocator);")


#####################
# </fields>
#####################


class Message(object):
	def __init__(self, full_name, descriptor):
		self.descriptor = descriptor
		self.full_name = full_name
		self.fields = []
		self.n_required_fields = 0
		for field in descriptor.field:
			f = get_field(field)
			setattr(f, '_message', self)
			if f.is_required() and not f.has_default_value():
				setattr(f, '_required_field_id', self.n_required_fields)
				self.n_required_fields += 1
			self.fields.append(f)

	def render(self, msg):
		return render(msg, self)

	def generate_tree(self):
		tree = {}
		for i, field_info in enumerate(self.fields):
			for tag, read_source in field_info.cases():
				f = tree
				for b in tag[:-1]:
					if not b in f:
						f[b] = {}
					f = f[b]
				b = tag[-1]
				if not b in f:
					f[b] = read_source
		return tree

	def MessageType(self):
		return to_TypeName(self.full_name)

	def message_type(self):
		return to_underlines(self.full_name).lower()

	def MESSAGE_TYPE(self):
		return to_underlines(self.full_name).upper()

	def has_repeated_fields(self):
		for f in self.fields:
			if f.is_repeated():
				return True
		return False

	def has_complex_fields(self):
		for f in self.fields:
			if f.is_complex():
				return True
		return False

	def has_repeated_complex_fields(self):
		for f in self.fields:
			if f.is_complex() and f.is_repeated():
				return True
		return False

	def has_packable_fields(self):
		for f in self.fields:
			if f.can_be_packed():
				return True
		return False

	def has_field_type(self, types):
		for f in self.fields:
			if f.type_name in types:
				return True
		return False

	def pack_uses_length_prediction_trick(self):
		for f in self.fields:
			if f.pack_with_length_prediction():
				return True
		return False

	def merge_unpack__additional_variables(self):
		out = []
		if self.has_packable_fields():
			out.append("const uint8_t* tmp_buffer_pointer = NULL;")
		if self.has_packable_fields() or self.has_field_type(('submessage',)):
			out.append("int32_t t = 0;")
		if self.has_complex_fields():
			out.append("uint32_t length = 0;")
		if len(self.fields) == 0:
			out.append("(void) message;")
		return self.render("\n".join(out))

	def free_unpacked__additional_variables(self):
		if self.has_repeated_complex_fields():
			return "unsigned i;"
		return ""

	def check__additional_variables(self):
		if self.has_repeated_complex_fields():
			return "unsigned i;"
		return ""

	def get_packed_size__additional_variables(self):
		if self.has_repeated_fields():
			return self.render("\n".join( ["unsigned i;", "size_t rv;"] ))
		return ""

	def pack__additional_variables(self):
		out = []
		if self.pack_uses_length_prediction_trick():
			out.append("uint8_t *varint_length_p;")
			out.append("size_t varint_length, length, reserved_length;")
		if self.has_repeated_fields():
			out.append("unsigned i;")
		return self.render("\n".join(out))

	def generated_methods(self):
		return self.render(MESSAGE_GENERATED_METHODS)

	def switch_tree(self, data=None, level=0):
		t = [
			"if (buffer + ${level} >= buffer_end) return PROTOBUF_C__WRONG_MESSAGE;" if level > 0 else "",
			"switch(buffer[${level}]) {",
			"	${cases}",
			"	default:",
			"		if ((buffer=skip_field(buffer, buffer_end)) == NULL) return PROTOBUF_C__WRONG_MESSAGE;",
			"		continue;",
			"}",
		]

		t = "\n".join([s for s in t if s])

		if data is None:
			data = self.generate_tree()

		cases = []
		for byte, subdata in data.items():
			c = "\n".join([s for s in [
				"case ${byte}:",
				"	buffer += ${level+1};" if type(subdata) is not dict else "",
				"	${body}",
				"	continue;",
			] if s])
			c_data = {'byte': hex(byte), 'level+1': level+1}
			if type(subdata) is dict:
				c_data['body'] = self.switch_tree(data=subdata, level=level+1)
			else:
				c_data['body'] = subdata
			cases.append(render(c, c_data))

		out = render(t, {'level':level, 'cases': "\n".join(cases)})
		return out

	def required_fields_words(self):
		return (self.n_required_fields + 63) / 64

	def required_fields_all_set(self):
		n = self.n_required_fields
		word_no = 0
		words = []
		while n > 0:
			bits = min(n, 64)
			words.append("required_fields[%u] == 0x%xUL" % (word_no, (1 << bits) - 1))
			n -= bits
		return " && ".join(words)

	def required_fields_init(self):
		if self.n_required_fields == 0:
			return ""
		return self.render("""uint64_t required_fields[${required_fields_words}] = {0};""")

	def required_fields_check(self):
		if self.n_required_fields == 0:
			return ""
		return """if (!(${required_fields_all_set})) return PROTOBUF_C__WRONG_MESSAGE;"""

	def free_fields(self):
		out = []
		for f in self.fields:
			if f.is_repeated():
				if f.is_complex():
					out.append(f.render("""
						for (i = 0; i < ${number}; i++) {
							${free}
						}
					"""))
				out.append(f.render("memory_free(${vector}, allocator);"));
			elif f.is_complex():
				out.append(f.render("${free}"));
		return render("\n".join(out), self)

	def check_fields(self):
		out = []
		for f in self.fields:
			if f.is_repeated():
				out.append(f.render("if (${number} > 0 && ${vector} == NULL) return 0;"))
				if f.type_name == 'submessage':
					out.append(f.render("""
						for (i = 0; i < ${number}; i++) {
							if (!${submessage}__check(${scalar})) return 0;
						}
					"""))
				elif f.type_name == 'string':
					out.append(f.render("""
						for (i = 0; i < ${number}; i++) {
							if (${scalar} == NULL) return 0;
						}
					"""))
				elif f.type_name == 'bytes':
					out.append(f.render("""
						for (i = 0; i < ${number}; i++) {
							ProtobufCBinaryData *bd = ${vector} + i;
							if (bd->len > 0 && bd->data == NULL) return 0;
						}
					"""))
			else:
				if f.type_name == 'submessage':
					if f.is_required():
						out.append(f.render("if (!${submessage}__check(${scalar})) return 0;"))
					else:
						out.append(f.render("if (${scalar} != NULL && !${submessage}__check(${scalar})) return 0;"))
				elif f.type_name == 'string':
					if f.is_required():
						out.append(f.render("if (${scalar} == NULL) return 0;"))
				elif f.type_name == 'bytes':
					if f.is_required():
						out.append(f.render("if (${scalar}.len > 0 && ${scalar}.data == NULL) return 0;"))
					else:
						out.append(f.render("if (${has} && ${scalar}.len > 0 && ${scalar}.data == NULL) return 0;"))
		return render("\n".join(out), self)

	def get_packed_size_fields(self):
		out = []
		for f in self.fields:
			out.append(f.render("""
				const size_t ${name}__tag_size = ${tag_size};
			"""))

		for f in self.fields:
			if f.is_repeated():
				if f.is_packed():
					out.append(f.render("""
						if (${number} > 0) {
							sz += ${name}__tag_size;
							${repeated_get_packed_size}
							sz += uint32_size(rv) + rv;
						}
					"""))
				else:
					out.append(f.render("""
						if (${number} > 0) {
							sz += ${name}__tag_size * ${number};
							${repeated_get_packed_size}
							sz += rv;
						}
					"""))
			elif f.is_optional():
				out.append(f.render("""
					if (${optional_needs_packing}) {
						sz += ${name}__tag_size;
						sz += ${get_packed_size};
					}
				"""))
			else:
				out.append(f.render("""
					sz += ${name}__tag_size;
					sz += ${get_packed_size};
				"""))
		return render("\n".join(out), self)

	def pack_fields(self):
		out = []
		for f in self.fields:
			if f.is_repeated():
				if f.is_packed():
					out.append(f.render("""
						if (${number} > 0) {
							${pack_packed_tag}
							${pack_length_prologue}
							for (i = 0; i < ${number}; i++) {
								${pack_scalar}
							}
							${pack_length_epilogue}
						}
					"""))
				else:
					out.append(f.render("""
						for (i = 0; i < ${number}; i++) {
							${pack}
						}
					"""))
			elif f.is_optional():
				out.append(f.render("""
					if (${optional_needs_packing}) {
						${pack}
					}
				"""))
			else:
				out.append(f.render("""
					${pack}
				"""))

		return render("\n".join(out), self)


class Module(object):
	def __init__(self, fdp):
		self.messages = []
		self.fdp = fdp
		def add_messages(prefix, messages):
			for dp in messages:
				if len(prefix):
					full_name = prefix + '.' + dp.name
				else:
					full_name = dp.name
				self.messages.append(Message(full_name, dp))
				add_messages(full_name, dp.nested_type)
		add_messages(fdp.package, fdp.message_type)

	def render(self, msg):
		return render(msg, self)

	def filename_proto(self):
		return self.fdp.name

	def filename_identifier(self):
		ret = ''
		for c in self.fdp.name:
			if c.isalpha():
				ret += c
			else:
				ret += '_%02x' % ord(c)
		return ret

	def filename(self):
		return self.fdp.name[:-len(".proto")]

	def source_filename(self):
		return self.filename()+".pb-c.c"

	def source(self):
		return self.render(COMMON_SOURCE)

	def pieces(self):
		for message in self.messages:
			yield message.message_type(), message.generated_methods()

def generate(res, fdp):
	module = Module(fdp)

	for insertion_point, content in module.pieces():
		c_file = res.file.add()
		c_file.name = module.source_filename()
		c_file.insertion_point = insertion_point
		c_file.content = content.replace("\t", "  ")

if __name__ == '__main__':
	import sys
	import google.protobuf.compiler.plugin_pb2 as plugin

	req = plugin.CodeGeneratorRequest()
	res = plugin.CodeGeneratorResponse()

	req.ParseFromString(sys.stdin.read())

	for fdp in req.proto_file:
		if fdp.name not in req.file_to_generate:
			continue
		if not fdp.name.endswith('.proto'):
			raise Exception("expected .proto file, got %s" % fdp.name)
		generate(res, fdp)

	print res.SerializeToString(),
